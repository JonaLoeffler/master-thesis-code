//! The explore module is concerned with generating all possible query execution plans or
//! operations for a given initial query execution plan and executing them on a given dataset for
//! performance evaluation.
//!
//! Parts of this implementation are concerned with generating all possible full binary trees for a
//! given set of nodes. Parts of the algorithm used have been taken from
//! [here](https://leetcode.com/problems/all-possible-full-binary-trees/solutions/2970045/just-a-runnable-solution/?languageTags=rust).

use std::{collections::HashMap, error::Error, time::Instant};

use iter_progress::ProgressableIter;
use itertools::Itertools;

use crate::{
    semantics::{
        operations::{
            visitors::{
                condition::ConditionAnalyzer, insert_filter::FilterInserter, optimize::Optimize,
            },
            Operation,
        },
        options::Optimizer,
        selectivity::SelectivityEstimator,
    },
    syntax::{
        database::Database,
        query::{Query, QueryVisitor},
    },
};

use super::{
    operations::{
        visitors::{all_plans::AllPlans, condition::ConditionInfo, planner::Planner},
        OperationVisitor,
    },
    results::QueryResult,
};

pub fn explore(query: Query, database: &Database) -> Result<Vec<QueryResult>, Box<dyn Error>> {
    let expanded = &query.expand()?;

    let initial = Planner::new(database).visit(expanded);
    let mut plans = AllPlans::new().visit(&initial)?;

    let info = ConditionAnalyzer::new().visit(expanded);
    let other = AllPlans::new().visit(&initial)?;
    let mut additional = other
        .iter()
        .map(|p| FilterInserter::new(info.clone()).visit(p))
        .collect();

    plans.append(&mut additional);

    let plans: Vec<Operation> = plans.into_iter().unique().collect();

    log::info!("Comparing {} different query plans", plans.len());

    let special = special_plans(&initial, database, &info)?;

    Ok(plans
        .into_iter()
        // .filter(|plan| special.iter().any(|(_, p)| p == plan))
        .enumerate()
        .progress()
        .map(|(state, (i, plan))| {
            log::info!(
                "--- Evaluating plan with ID {i} ({:.2}% done, ETA: ) ---\n{}\n",
                state.percent().unwrap_or_default(),
                plan,
            );

            let optimizers: Vec<Optimizer> = special
                .iter()
                .filter(|(_, p)| **p == plan)
                .map(|((o, _), _)| *o)
                .collect();

            if !optimizers.is_empty() {
                log::info!("Plan is idential to plans generated by {:?}", optimizers);
            }

            let meta = plan.meta();

            let now = Instant::now();
            QueryResult::select(plan.collect())
                .with_run_duration(now.elapsed())
                .with_optimizers(optimizers)
                .with_meta(Some(meta))
                .discard_mappings()
        })
        .collect())
}

fn special_plans<'a>(
    initial: &'a Operation,
    database: &'a Database,
    info: &'a ConditionInfo,
) -> Result<HashMap<(Optimizer, bool), Operation<'a>>, Box<dyn Error>> {
    let mut special = HashMap::new();

    let with_filter_pushing = initial.meta().filters > 0;

    special.insert(
        (Optimizer::Off, false),
        Optimize::new(SelectivityEstimator::Off).visit(initial)?,
    );
    special.insert(
        (Optimizer::Fixed, false),
        Optimize::new(SelectivityEstimator::Fixed).visit(initial)?,
    );
    special.insert(
        (Optimizer::Arqpf, false),
        Optimize::new(SelectivityEstimator::Arqpf(database.summary())).visit(initial)?,
    );
    special.insert(
        (Optimizer::Arqpfc, false),
        Optimize::new(SelectivityEstimator::Arqpfc(database.summary(), info)).visit(initial)?,
    );
    special.insert(
        (Optimizer::Arqpfj, false),
        Optimize::new(SelectivityEstimator::Arqpfj(database.summary())).visit(initial)?,
    );
    special.insert(
        (Optimizer::Arqpfjc, false),
        Optimize::new(SelectivityEstimator::Arqpfjc(database.summary(), info)).visit(initial)?,
    );
    special.insert(
        (Optimizer::Arqvc, false),
        Optimize::new(SelectivityEstimator::Arqvc).visit(initial)?,
    );
    special.insert(
        (Optimizer::Arqvcp, false),
        Optimize::new(SelectivityEstimator::Arqvcp).visit(initial)?,
    );

    if with_filter_pushing {
        special.insert(
            (Optimizer::Off, true),
            Optimize::new(SelectivityEstimator::Off)
                .with_condition(true)
                .visit(initial)?,
        );
        special.insert(
            (Optimizer::Fixed, true),
            Optimize::new(SelectivityEstimator::Fixed)
                .with_condition(true)
                .visit(initial)?,
        );
        special.insert(
            (Optimizer::Arqpf, true),
            Optimize::new(SelectivityEstimator::Arqpf(database.summary()))
                .with_condition(true)
                .visit(initial)?,
        );
        special.insert(
            (Optimizer::Arqpfc, true),
            Optimize::new(SelectivityEstimator::Arqpfc(database.summary(), info))
                .with_condition(true)
                .visit(initial)?,
        );
        special.insert(
            (Optimizer::Arqpfj, true),
            Optimize::new(SelectivityEstimator::Arqpfj(database.summary()))
                .with_condition(true)
                .visit(initial)?,
        );
        special.insert(
            (Optimizer::Arqpfjc, true),
            Optimize::new(SelectivityEstimator::Arqpfjc(database.summary(), info))
                .with_condition(true)
                .visit(initial)?,
        );
        special.insert(
            (Optimizer::Arqvc, true),
            Optimize::new(SelectivityEstimator::Arqvc)
                .with_condition(true)
                .visit(initial)?,
        );
        special.insert(
            (Optimizer::Arqvcp, true),
            Optimize::new(SelectivityEstimator::Arqvcp)
                .with_condition(true)
                .visit(initial)?,
        );
    }

    Ok(special)
}
