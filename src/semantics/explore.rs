use std::{collections::HashMap, error::Error, time::Instant};

use iter_progress::ProgressableIter;

use crate::{
    semantics::{
        operations::visitors::optimize::Optimize, options::Optimizer,
        selectivity::SelectivityEstimator,
    },
    syntax::{
        database::Database,
        query::{Query, QueryVisitor},
    },
};

use super::{
    operations::{
        visitors::{all_plans::AllPlans, planner::Planner},
        OperationVisitor,
    },
    results::QueryResult,
};

pub fn explore(query: Query, database: &Database) -> Result<Vec<QueryResult>, Box<dyn Error>> {
    let expanded = &query.expand()?;

    let initial = Planner::iter(&database).visit(&expanded);
    let plans = AllPlans::iter().visit(&initial)?;

    log::info!("Comparing {} different query plans", plans.len());

    let mut special = HashMap::new();

    special.insert(
        Optimizer::Off,
        Optimize::iter(SelectivityEstimator::Off).visit(&initial)?,
    );
    special.insert(
        Optimizer::Fixed,
        Optimize::iter(SelectivityEstimator::Fixed).visit(&initial)?,
    );
    special.insert(
        Optimizer::ARQPF,
        Optimize::iter(SelectivityEstimator::ARQPF(&database.summary())).visit(&initial)?,
    );
    special.insert(
        Optimizer::ARQPFJ,
        Optimize::iter(SelectivityEstimator::ARQPFJ(&database.summary())).visit(&initial)?,
    );
    special.insert(
        Optimizer::ARQVC,
        Optimize::iter(SelectivityEstimator::ARQVC).visit(&initial)?,
    );
    special.insert(
        Optimizer::ARQVCP,
        Optimize::iter(SelectivityEstimator::ARQVCP).visit(&initial)?,
    );

    Ok(plans
        .into_iter()
        .enumerate()
        .progress()
        .map(|(state, (i, plan))| {
            log::info!(
                "--- Evaluating plan with ID {i} ({:.2}% done, ETA: ) ---\n{}\n",
                state.percent().unwrap_or_default(),
                plan,
            );

            let optimizers: Vec<Optimizer> = special
                .iter()
                .filter(|(_, p)| **p == plan)
                .map(|s| s.0.clone())
                .collect();

            if optimizers.len() > 0 {
                log::info!("Plan is idential to plans generated by {:?}", optimizers);
            }

            let meta = plan.meta();

            let now = Instant::now();
            QueryResult::select(plan.collect())
                .with_duration(now.elapsed())
                .with_optimizers(optimizers)
                .with_meta(Some(meta))
        })
        .collect())
}
